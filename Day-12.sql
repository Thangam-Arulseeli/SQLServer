--Why do we need Exception Handling in SQL Server?
--Types of exceptions in SQL Server
--There are two types of exceptions in SQL Server. These are:

--System Defined Exceptions
--User-Defined Exceptions
--System Defined Exceptions: These are the exceptions that are generated by the system during the program execution. 
--The error messages are predefined in the system and the final user will see the predefined message on the console.
--User-Defined Exceptions: These are the exceptions that are thrown explicitly by the programmer. 
--The programmer can raise exceptions at any part of the SQL code according to the logic he has implemented in the program.

use trainees;
ALTER PROCEDURE spDivideTwoNumber(
@Number1 INT, 
@Number2 INT
)
AS
BEGIN
    DECLARE @Result INT
    SET @Result = 0
    SET @Result = @Number1 / @Number2
    PRINT 'RESULT IS :'+CAST(@Result AS VARCHAR)
END

EXEC spDivideTwoNumber 100, 5

EXEC spDivideTwoNumber 100, 0

--Exception Handling Using RAISERROR System Function in SQL Server:

ALTER PROCEDURE spDivideTwoNumber
@Number1 INT, 
@Number2 INT
AS
BEGIN
    DECLARE @Result INT
    SET @Result = 0
    IF(@Number2 = 0)
    BEGIN
         RAISERROR('Second Number Cannot be zero', 16, 7) --(MSG,SEVERITY,STATE)
    END
    ELSE
    BEGIN
        SET @Result = @Number1 / @Number2
        PRINT 'RESULT IS : '+ CAST(@Result AS VARCHAR)
    END
END

EXEC spDivideTwoNumber 100, 0

/*What is RaiseError System Function in SQL Server?
The RaiseError System defined Function in SQL Server takes 3 parameters as shown below. 
RAISERROR(�Error Message�, ErrorSeverity, ErrorState)
Error Message: The custom error message that you want to display whenever the exception is raised.
Error Severity: When we are returning any custom errors in SQL Server, we need to set the ErrorSeverity level as 16, which indicates this is a general error and this error can be corrected by the user. In our example, the error can be corrected by the user by giving a nonzero value for the second parameter.
Error State: The ErrorState is also an integer value between 1 and 255. The RAISERROR() function can only generate custom errors if you set the Error State value between 1 to 127.*/


--@@Error System Function in SQL Server:
--The @@Error system function returns a NON-ZERO value if there is an error, otherwise, ZERO indicates that the previous SQL statement was executed without any error. 

ALTER PROCEDURE spDivideTwoNumber
@Number1 INT, 
@Number2 INT
AS
BEGIN
  DECLARE @Result INT
  SET @Result = 0
  IF(@Number2 = 0)
  BEGIN
    RAISERROR('Second Number Cannot be zero',16,1)
  END
  ELSE
  BEGIN
    SET @Result = @Number1 / @Number2
  END
  IF(@@ERROR <> 0)
  BEGIN
    PRINT 'Error Occurred'
  END
  ELSE
  BEGIN
    PRINT 'RESULT IS :'+CAST(@Result AS VARCHAR)
  END
END

EXEC spDivideTwoNumber 100, 0

--EXAMPLE @@ERROR
select * from trainees35
 
UPDATE trainees35 
    SET depid=1000 
    WHERE depid=100;  
IF @@ERROR = 547
    BEGIN
    PRINT N'A constraint violation occurred.';
    END
GO

--Predefined Error Terms in SQL Server:
/*Whenever an error occurs under a program like dividing a number by zero, 
violation of primary key, 
violation of Check constraint, etc. 
the system displays an error message telling us the problem encountered in the code.
Every error that occurs in the program is associated with four attributes.
Error Number
Error Message
Severity Level
Error State
Example:
Message 8134 (Error Number), Level 16(SEVERITY Level), State 1 (state), Divide by Zero error encountered (Error Message)*/

/*
Error Number: The Error number is a unique identifier given for each and every error that occurs in SQL Server. This value will be below 50,000 for predefined errors and must be above or equals to 50,000 for errors defined by the user. 
While raising custom errors, if we don�t specify the error number, then by default it will set the Error Number as 50000.
Error Message: It is a piece of brief information describing the error that occurred which should be maxing from 2047 characters.
Severity Level: This tells about the importance of the error which can be ranging between 0 to 24. In which
0 to 9: are not serves which can be considered as information or status messages.
11 to 16:  Indicates these errors can be created by the user.
17 to 19: Indicates these are software errors that cannot be corrected by the user must be reported to the system administrator.
20 to 24: Indicates fatal errors and if these errors occur they can damage the system or database. So here the connection immediately terminates with the database.
State: It is an arbitrary value that is not that important can be ranging between 0 to 127. We use this whenever the same error has to occur in multiple places.
Note: We can find the information of all predefined errors under the table �Sys.Messages�*/

SELECT * FROM SYS.messages;
---------------------------------------------------------------
--How to Raise Errors Explicitly in SQL Server?

--Example: Raise Error using RAISERROR statement in SQL Server.

CREATE PROCEDURE spDivideBy1(@No1 INT, @No2 INT)
AS
BEGIN
  DECLARE @Result INT
  SET @Result = 0
  BEGIN TRY
    IF @No2 = 1
    RAISERROR ('DIVISOR CANNOT BE ONE', 16, 1) -- ERROR NUMBER IS 50000 BY DEFAULT
    SET @Result = @No1 / @No2
    PRINT 'THE RESULT IS: '+CAST(@Result AS VARCHAR)
  END TRY
  BEGIN CATCH
    PRINT ERROR_NUMBER()
    PRINT ERROR_MESSAGE()
    PRINT ERROR_SEVERITY()
    PRINT ERROR_STATE()
  END CATCH
END

 EXEC spDivideBy1 10, 0 
 EXEC spDivideBy1 10, 1
 EXEC spDivideBy1 10, 10

 --Example: Raise Error using throw statement in SQL Server.

CREATE PROCEDURE spDivideBy2(@No1 INT, @No2 INT)
AS
BEGIN
  DECLARE @Result INT
  SET @Result = 0
  BEGIN TRY
    IF @No2 = 1
    THROW 50001,'DIVISOR CANNOT BE ONE', 1
    SET @Result = @No1 / @No2
    PRINT 'THE RESULT IS: '+CAST(@Result AS VARCHAR)
  END TRY
  BEGIN CATCH
    PRINT ERROR_NUMBER()
    PRINT ERROR_MESSAGE()
    PRINT ERROR_SEVERITY()
    PRINT ERROR_STATE()
  END CATCH
END

EXEC spDivideBy2 10, 1
EXEC spDivideBy2 10, 0
/*
What is the difference between the RAISERROR function and the throw statement in SQL Server?
If we use any of the two statements in a program for raising a custom error without try and catch blocks, 
the RAISERROR statement after raising the error will still continue the execution of the program 
whereas the throw statement will terminate the program abnormally on that line. 
But if they are used under try block both will behave in the same way that it will jump directly 
to catch block from where the error got raised.
The RAISERROR statement will give an option of specifying the ERROR SEVERITY Level of the error message 
whereas we don�t have this option in the case of the throw statement where all error messages will have a default  ERROR SEVERITY level as 16.
In the case of RAISERROR, there is a chance of recording the error message into the server log file by using 
the with log option whereas we cannot do this in case of a throw statement. 
In the case of throw, we need to specify both the errorid and error message to raise the error 
whereas in the case of RAISERROR we can specify either id or message. 
If the id is not specified default error id is 50000 but 
if we want to specify only the error id first we need to add the error message 
in the sysmessage table by specifying a unique id to the table.*/

/*
OPTIONS WITH RAISERROR STATEMENT:
With Log: By using this option in the RAISERROR statement we can record the error message in the SQL Server log file 
so that if the errors are fatal database administrator can take care of fixing those errors. 
If the severity of the error is greater than 20 specifying the With Log option is mandatory. 
To test this ALTER the procedure spDivideBy1 by changing the raiserror statement as following
RAISERROR (�DIVISOR CANNOT BE ONE�, 16, 1) WITH LOG*/

ALTER PROCEDURE spDivideByONE(@No1 INT, @No2 INT)
AS
BEGIN
  DECLARE @Result INT
  SET @Result = 0
  BEGIN TRY
    IF @No2 = 1
    RAISERROR ('DIVISOR CANNOT BE ONE', 16, 1) WITH LOG
    SET @Result = @No1 / @No2
    PRINT 'THE RESULT IS: '+CAST(@Result AS VARCHAR)
  END TRY
  BEGIN CATCH
    PRINT ERROR_NUMBER()
    PRINT ERROR_MESSAGE()
    PRINT ERROR_SEVERITY()
    PRINT ERROR_STATE()
  END CATCH
END

--CHECK IN MANAGEMENT-SQL SERVER LOGS
---------------------------------------------------------------
--EXAMPLES

--LOGIN

create table Login
(
Username varchar(25) Primary key,
Password varchar(25)
)

select * from Login


ALTER PROCEDURE InsertRecord @Username nchar(20), @Password nchar(20)
AS
BEGIN
	INSERT INTO [dbo].[Login](Username, Password)
	VALUES(@Username, @Password)
END

EXEC InsertRecord 'Sam', 'sam@123'

ALTER PROCEDURE InsertRecord @Username nchar(20), @Password nchar(20)
AS
BEGIN
	BEGIN TRY
		INSERT INTO [dbo].[Login](Username, Password)
		VALUES(@Username, @Password)
	END TRY

	BEGIN CATCH
		PRINT('The username is already taken. Try another one')
	END CATCH
END

-------------

--ONLINECUSTOMERS
CREATE PROCEDURE FindCustomer @CustomerID int
AS
BEGIN
	IF EXISTS(SELECT * FROM onlinecustomers where [CustomerID]=@CustomerID)
		PRINT('Customer is present')
	ELSE
		THROW 50001,'Error! No customer with this ID',1
	PRINT('Thank You')
END

EXEC FindCustomer 21

----------------
SELECT * FROM Department;

CREATE TABLE DB_Errors
         (ErrorID        INT IDENTITY(1, 1),
          UserName       VARCHAR(100),
          ErrorNumber    INT,
          ErrorState     INT,
          ErrorSeverity  INT,
          ErrorLine      INT,
          ErrorProcedure VARCHAR(MAX),
          ErrorMessage   VARCHAR(MAX),
          ErrorDateTime  DATETIME)

ALTER PROCEDURE sp_dep @did INT,@dname VARCHAR(25)
AS
  BEGIN TRY
    INSERT INTO Department
         SELECT
			@did,
			@dname
  END TRY
  BEGIN CATCH
    INSERT INTO dbo.DB_Errors
    VALUES
  (SUSER_SNAME(),
   ERROR_NUMBER(),
   ERROR_STATE(),
   ERROR_SEVERITY(),
   ERROR_LINE(),
   ERROR_PROCEDURE(),
   ERROR_MESSAGE(),
   GETDATE());
  END CATCH
GO

EXEC sp_dep 100, 'Testing'

select * from DB_Errors